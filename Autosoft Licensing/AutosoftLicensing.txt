AutoSoft License Manager Purpose: This desktop application is a license management module for AutoCount plugins. It allows generating license requests, importing/validating license files, and storing license metadata. It supports two license types – a fixed 1-month Demo license and a Paid Subscription (default 12-month, adjustable duration) – using custom file formats (.ARL for requests and .ASL for activations). The tool runs inside the AutoCount plugin environment (not as a standalone executable) and uses a DevExpress WinForms UI for a smooth workflow. Project Overview: Language & Framework: C# on .NET Framework 4.8 or .NET 6+ (WinForms). Use DevExpress.XtraEditors.XtraForm as the main window (MainForm.cs). The main form will serve as a container for all pages, using a combination of: •	AccordionControl (left navigation) or NavBarControl for sidebar menu •	PanelControl or NavigationFrame on the right to dynamically load UserControls for each page Each page (Dashboard, Generate Request, Import License, etc.) will be implemented as a separate UserControl located under /UI/Pages/. WizardControl may be optionally used inside specific pages only (e.g., for a step-by-step license request creation flow), but the overall application structure is not wizard-based. XtraForm offers greater flexibility and is better suited for an 8-page administrative tool like this one. Integration: The application is launched by the AutoCount plugin and is not a separate standalone app. On each plugin startup, it should validate the license and disable the main plugin UI if the license is missing or expired. Business Rules & Logic – License Management Module 1. License Types & Duration 1.1 : Supported license types: Demo License  – Validity fixed at  1 month  from issuance. Subscription License– Validity included is 3, 6, 12, 24 months. Perpetual License ; admin can adjust to a longer duration manually. 1.2 : Renewal and payment approval are handled  outside  the system (manual process).  2. License Request File Rules 2.1 : A valid license request file  must include  the following fields: Company Name Period of Validity (requested duration) Dealer Code Product ID License Type (Demo or Paid) License Key Currency Code (optional but preferred) 2.2 : The system must validate that all mandatory fields are present and not empty. 2.3 : The system must reject any request file with missing fields or invalid/tampered content and return: Error message:  “Invalid license request file.”  3. License Generation Rules 3.1 : The generated license file must contain: Company Name: [Company Name] Product ID: [Product ID] Currency Code: [Currency Code] License Key: [Generated License Key] 3.2 : License generation does  not  depend on any system approval; approval and payment verification occur manually outside the system.  4. Security Rules 4.1 : All generated license files must be  encrypted  (encryption algorithm TBD). 4.2 : Each generated license file must include a  checksum/hash  for tamper detection (algorithm TBD). 4.3 : When a license file is uploaded, the system must verify its integrity. If checksum/hash verification fails → Error message:  “Invalid or tampered license file.”  5. Error Handling Rules  5.1 : Wrong or unsupported file format → Error message:  “Invalid license file.” 5.2 : Expired license → Error message:  “License expired.” 5.3 : No logs are stored for audit; only error messages are shown to the user (as per current requirements).  6. License Validation & Usage Rules 6.1 : License validity check occurs  every time a user logs in to AutoCount . 6.2 : For  expired demo licenses : Show a warning message:  “Demo license expired.” Hide the plugin from the AutoCount tab until renewed.  7. Confirmed Assumptions (for developers) 1 : Encryption and checksum/hash algorithm details will be decided and implemented later. 2 : There is  no central server  storing license data; all license data is maintained manually by the admin. 3 : Upload/validation flows do  not  store logs or audit records. License File Formats: .ARL (Autosoft Request License): A JSON-based request file. It includes fields like Company Name Period of Validity (requested duration) Dealer Code Product ID License Type (Demo or Paid) License Key Currency Code (optional but preferred) (Stated in business rule). This file is generated by the License Request UI step. Use JSON serialization to write out a .ARL file (e.g. using a helper like JsonHelper). .ASL (Autosoft Solution License): A JSON license file that has been encrypted and encoded. Internally, it contains fields such as CompanyName, LicenseType, Validity (end date), LicenseKey, and optionally CurrencyCode, (based on the ARL and the field you think required). The JSON is encrypted with AES-256 and then Base64-encoded into the .ASL file. A SHA-256 checksum of the decrypted data is included to detect tampering. (In practice, encrypt the JSON bytes using a 256-bit AES key/IV, then use Convert.ToBase64String to save it. To validate, decode Base64 and decrypt with the same key/IV.) 1 — High-level goals (quick) Support .ARL request files and .ASL activation files (custom formats; JSON → AES256 encrypted + Base64). Enforce Business Rules (Demo = 1 month, Paid default 12 months, only Demo/Paid). Validate on every AutoCount login; hide plugin if invalid/expired. Admin can CRUD users, dealers, products, license records, and request history. No central server; local SQL Server (AutoCount environment). No persistent logs/audit are stored (per requirement) — only show transient UI messages. 2 — File formats (precise JSON schemas) .ARL — Autosoft Request License (plaintext JSON saved as .ARL) Must include all mandatory fields. If missing → Invalid license request file. { "CompanyName": "string",               // required, non-empty "ProductID": "string",                 // required, non-empty "DealerCode": "string",                // required, non-empty "RequestedPeriodMonths": 12,           // required integer (Demo requests may be 1) "LicenseType": "Demo|Paid",            // required, only "Demo" or "Paid" "LicenseKey": "string",                // required (can be blank? spec says required) "CurrencyCode": "USD",                 // optional but preferred "RequestDateUtc": "2025-11-11T08:00:00Z" // required ISO8601 } Validation (on import): all required fields present and non-empty; LicenseType is Demo or Paid; RequestedPeriodMonths >=1 and reasonable (e.g., <= 1200). If fail → return "Invalid license request file.". .ASL — Autosoft Solution License The .ASL file content = Base64( AES256_encrypt( JSON_WITH_CHECKSUM ) ). Decrypted JSON structure: { "CompanyName": "string", "ProductID": "string", "DealerCode": "string", "CurrencyCode": "string",       // optional "LicenseType": "Demo|Paid", "ValidFromUtc": "2025-11-01T00:00:00Z", "ValidToUtc": "2026-10-31T23:59:59Z", "LicenseKey": "generated-string", "ChecksumSHA256": "hex-or-base64" // SHA256 of the canonical JSON (without checksum) or the raw JSON bytes — choose one consistently } Validation: Base64 decode → AES decrypt → recompute checksum → compare. If checksum mismatch or decryption error → "Invalid or tampered license file.". If ValidToUtc < now → "License expired." (for Demo specifically show "Demo license expired." and hide plugin). Recommendation: canonicalize JSON (sorted keys, UTF-8) before hashing so checksum stable. 3 — Database schema (SQL Server) — essential tables Use local DB (AutoCount DB or separate local DB). Add indexes for lookups. Licenses (current & history) Column Type Notes Id INT IDENTITY PK CompanyName NVARCHAR(255) ProductID NVARCHAR(100) DealerCode NVARCHAR(50) LicenseKey NVARCHAR(200) LicenseType NVARCHAR(20) Demo / Paid ValidFromUtc DATETIME2 ValidToUtc DATETIME2 CurrencyCode NVARCHAR(10) nullable Status NVARCHAR(20) Valid / Expired / Invalid ImportedOnUtc DATETIME2 when admin imported .ASL ImportedByUserId INT FK Users.Id (nullable) RawAslBase64 NVARCHAR(MAX) store encrypted file if required; optional — if you truly must not keep license files, omit column; but storing encrypted raw file helps admin re-import. Requirement 7 says all license data maintained manually by admin; choose whether to store. LicenseRequests Column Type Id (PK) INT CompanyName NVARCHAR(255) ProductID NVARCHAR(100) DealerCode NVARCHAR(50) LicenseType NVARCHAR(20) RequestedPeriodMonths INT LicenseKey NVARCHAR(200) CurrencyCode NVARCHAR(10) RequestDateUtc DATETIME2 RequestFileBase64 NVARCHAR(MAX) CreatedByUserId INT FK Users (basic CRUD) Column Type Id INT PK Username NVARCHAR(100) DisplayName NVARCHAR(200) Role NVARCHAR(20) Email NVARCHAR(200) PasswordHash NVARCHAR(512) CreatedUtc DATETIME2 Dealers, Products (optional reference tables) Basic tables for DealerCode and ProductID metadata. 4 — C# Models (complete list) Models/LicenseRequest.cs Models/LicenseData.cs (decrypted .ASL) Models/LicenseMetadata.cs (maps to Licenses table) Models/LicenseRequestRecord.cs (maps to LicenseRequests) Models/User.cs Models/Dealer.cs, Models/Product.cs DTOs for UI data shapes if you want separation. Each model gets data annotations (for validation) and JSON serialization attributes. 5 — Services & Interfaces (full CRUD & functions) Create interfaces to ease unit testing and Copilot generation: IUserService •	User GetById(int id) •	IEnumerable<User> GetAll() •	User Create(User u) •	User Update(User u) •	void Delete(int id) •	bool ValidateCredentials(string username, string password) ILicenseRequestService •	LicenseRequest ParseArlFile(string pathOrBase64) •	ValidateRequest(LicenseRequest r) -> ValidationResult •	SaveRequest(LicenseRequest, createdBy) •	IEnumerable<LicenseRequestRecord> QueryRequests(...) IFileService •	string ReadFileBase64(string path) •	void WriteFileBase64(string path, string base64content) •	byte[] ReadBytes(string path) •	void SaveBytes(string path, byte[] content) IEncryptionService •	string EncryptJsonToAsl(string json, byte[] key, byte[] iv) •	string DecryptAslToJson(string base64Asl, byte[] key, byte[] iv) •	string ComputeSha256Hex(byte[] data) •	bool VerifyChecksum(string jsonWithoutChecksum, string checksum) ILicenseService •	LicenseData ImportAslFile(string path, int importedByUserId) •	ValidateLicenseData(LicenseData): ValidationResult •	LicenseMetadata ActivateLicense(LicenseData, int importedByUserId) •	LicenseMetadata GetActiveLicenseForProduct(string productId, string companyName) •	IEnumerable<LicenseMetadata> GetAllLicenses(...) ILicenseDatabaseService •	CRUD methods for LicenseMetadata and LicenseRequests Other service features required: IValidationService for shared validations (field non-empty, ranges). IClock abstraction for time (helps unit test expiry logic). 6 — UI: 8 pages (matches wireframe) The wireframe shows 8 screens/pages. Implemented as UserControls inside the XtraForm main window The MainForm will handle navigation logic and load the correct UserControl into a PanelControl or NavigationFrame. Each page should be designed as an independent, reusable control with its own services and validation. : Dashboard / Overview Top summary: active license status (company, product, expiry), big status badge (Valid/Expired/Missing). Quick actions: Generate Request, Import License, Manage Users. Important warnings visible here. Generate Request (ARL creator) Form for CompanyName, ProductID (dropdown), DealerCode, LicenseType (Demo/Paid), RequestedPeriodMonths (auto 1 for Demo), CurrencyCode, LicenseKey input. Validate required fields on Save; exports .ARL. Offer “Save .ARL” and “Copy to clipboard” actions. Request History / Request Manager Grid showing previously created .ARL entries with columns from LicenseRequests. CRUD: view details, re-export .ARL, delete. Import/Activate License (.ASL) File chooser to pick .ASL. On import: read file, attempt decrypt & checksum verify; show a detailed result dialog (license fields). Buttons: Activate (persist to Licenses table), Cancel. On checksum failure → show "Invalid or tampered license file.". On success → show "License imported successfully." License List / Management Grid displaying Licenses table. Columns: Company, Product, LicenseType, ValidFrom, ValidTo, Status, ImportedOn. Actions: View, Deactivate (if admin), Re-import, Export ASL (optional), Delete. License Details / Manual Edit For admin: view the decrypted license data, allow manual adjustment of ValidTo (spec says admin can adjust duration manually). If admin adjusts expiry: update Licenses record status accordingly (but record change only in DB; no external approval). User & Access Management CRUD for users (Admin, Support). Permissions: only Admin can import/activate or edit licenses. Settings / Security AES key/IV configuration (for dev/testing, store in app config encrypted). Mark these as TBD for production. Option to enable/disable storing raw .ASL and .ARL (toggle). Option: set default save folder for files. Note: Because of the no-audit requirement, do not add persistent logs here. Show transient validation messages only. 7 — UI behavior & error messages (definitive mapping) Missing required fields in .ARL -> show modal: "Invalid license request file." Unsupported file type / cannot decode base64 -> "Invalid license file." AES decrypt error or checksum mismatch -> "Invalid or tampered license file." License expired -> "License expired." Demo expired -> show "Demo license expired." and hide plugin tab. Import success -> "License imported successfully." (show license summary) All errors are shown as modal popups or notification banners; do not persist error logs. 8 — Edge cases & how to handle them (prevent bugs) Partial/Corrupted .ARL: Validate every ARL field before writing. Use explicit DTO validation (DataAnnotations + runtime checks). Reject and show "Invalid license request file.". Clock changes / timezone issues: Use UTC for store and validation (DateTime.UtcNow). Provide IClock for tests. Wrong LicenseType: If .ASL contains a license type not Demo/Paid, treat as invalid/tampered. Replay attack (same LicenseKey used multiple times): Because no central server, accept but track in DB and show warnings in UI if duplicate license key imported (not blocked). AES key mismatch between issuer and plugin: Decrypt will fail → show "Invalid or tampered license file." Provide admin guidance in Settings. Admin overrides expiry: Keep changes in DB; require Admin role. No audit log stored per requirement, but consider prompting user to record the manual change offline. Concurrent imports: DB should enforce transactional operations and consistent status updates. Use transactions for import/activate steps. // PROJECT: AutoSoft License Manager // DESCRIPTION: DevExpress WinForms C# application for AutoCount plugin licensing. // GOALS: // - Create .ARL (request) and .ASL (activation) file flows. // - AES-256 encrypt .ASL content, compute SHA-256 checksum. // - Validate license on each AutoCount login; hide plugin on expired demo. // - Local SQL Server storage for license metadata and request history. // - No persistent audit logs; show UI messages only. // FOLDER STRUCTURE: /Models /Services /UI /Utils /Database


// NOTE: This is a high-level overview and structure for the AutoSoft License Manager project. Each component (models, services, UI pages) will need to be implemented in detail according to the specifications provided above.


1) Scope clarification — what you are building (Autosoft Licensing)

Make this the first paragraph you paste to Copilot / put in your README.

Scope (Your responsibility — “Autosoft Licensing”):

Build two deliverables as part of the Autosoft Licensing scope (you implement both):

License Generator Application (Dealer EXE) — a standalone Windows app used by the dealer (Autosoft) to consume .ARL request files and produce signed .ASL license files.

License UI Library (Client DLL) — a reusable Class Library (DLL) that is embedded into each AutoCount plugin. It handles creation of .ARL, accepts .ASL for registration, validates licenses, exposes a simple API to the plugin, and stores the license locally.

Out of scope for you: Actual AutoCount plugin projects that reference the DLL (other developers will integrate those). Also out-of-scope: central server implementation (there is none per requirement).




Overall Licensing Flow (annotated — who owns each step)

[Customer / AutoCount Plugin side — handled by plugin developers; NOT implemented by Autosoft Licensing team]
A. User installs AutoCount plugin (customer).
B. Plugin detects no license or expired license and calls into the License UI Library (DLL) to show license UI.

[Autosoft Licensing (YOUR PART) — you implement both 1 & 2 below]
1) Client-side: License UI Library (DLL) — *implemented by Autosoft Licensing*
   - Responsibility:
     - Provide UI for "Save Request File (.ARL)" and "Register By File (.ASL)".
     - Collect company information and machine fingerprint (via AutoCount APIs exposed to plugin).
     - Build, validate, and export `.ARL` (Autosoft Request License) JSON.
     - Read `.ASL`, decode (Base64), decrypt (AES-256), verify checksum (SHA-256), validate fields (CompanyName, ProductID, DealerCode, ValidToUtc etc).
     - If valid, persist validated license metadata locally (encrypted file or registry or plugin-local DB). Expose `IsValidLicense()` and other helper APIs for plugin to query.
   - Output: `.ARL` (to be sent to dealer), ability to import `.ASL`.

2) Dealer-side: Licensing Generator Application (EXE) — *implemented by Autosoft Licensing*
   - Responsibility:
     - Load `.ARL` (JSON) sent by customer.
     - Validate `.ARL` content (required fields present).
     - Generate license manifest (JSON) with required fields (CompanyName, ProductID, DealerCode, LicenseType, ValidFromUtc, ValidToUtc, LicenseKey, CurrencyCode).
     - Compute checksum (SHA-256) over canonical JSON (without checksum field), add `ChecksumSHA256`.
     - Encrypt JSON+checksum with AES-256 using dealer-private key/keystore/secret and output `.ASL` as `Base64( AES256(ciphertext) )`.
     - Ensure private key remains in EXE environment and never exported.
   - Output: `.ASL` file returned to customer.

[Customer / AutoCount Plugin side — handled by plugin developers & your DLL]
C. Customer imports `.ASL` using the License UI Library (DLL) in plugin. DLL validates `.ASL`. On success, plugin allows features; otherwise shows appropriate message.










Overall Licensing Flow (Including parts outside of scope):

1. Licensing Generator Application (Dealer Side – .exe)
Purpose
This standalone Windows application is used exclusively by the dealer (Autosoft) to generate license files for customers.
Key Responsibilities
Load customer’s Request File (.ARL)
The customer sends a .ARL file generated from the plugin. The dealer uploads this file into the app.
Produce License File (.ASL)
Read customer information from .ARL
Generate a signed license payload (expiry, module info, machine info, etc.)
Output a secure .ASL license file to send back to customer
Maintain Dealer Control
The private key never leaves this application.
Only the dealer can generate valid licenses.
Output
.ASL – Autosoft Solution License
2. License UI Library (Client Side – DLL)



Purpose
This is a reusable UI + logic DLL that is embedded into each AutoCount plugin to handle license request creation, license registration, and validation.
 
Output
The output for the project is a .dll file. In the project setting, the application type will be Class Library
Example:


It will be used as a reference in each plugin project
Example:


Key Responsibilities
Provide the License UI Window
"Request License"
"Register By File"
Generate Request File (.ARL)
The DLL collects:
Machine details (depends on what you want to make it as a unique key)
Company name (got from AutoCount database)
Plugin name &product key (got from plugin projetc)
Then creates .ARL (Autosoft Request License) for the dealer.
Load and Validate .ASL
The signature (license key)
Expiry date
Machine matching (the right account book)
Plugin matching (the right plugin)
Store License Data for the Plugin
After validation, it saves the license details (e.g., encrypted XML or registry).
Why Separate Project
This DLL can be reused by all plugin projects without duplicating code.
 

3. AutoCount Plugin Project (Actual Plugin)
Purpose
This is the real AutoCount plugin that the customer installs.
It consumes the License UI DLL and depends on it to control access to plugin features.
Key Responsibilities
Show License UI
On first launch or if license is missing/expired, the plugin opens the License UI from the library.
Use License Data from the UI DLL
Reads validated license information
Enables or disables plugin modules based on license terms
Provide Data for Request File (via License UI DLL)
The plugin provides the necessary AutoCount data (e.g., company info, plugin name), and the DLL handles generating the .ARL.
How to get the value from AutoCount
The .dll will be added as a reference in the plugin project. The programmer then call its methods to retrieve all necessary license information—such as Product Key, Product Name, Company Name—from AutoCount and the plugin project. These values will then be compiled into a Request File, which the user will upload to the license generator to obtain the licensed file.
 
Plugin project credentials are hardcoded
(
Public Class FreelyPlugIns

Inherits AutoCount.PlugIn.BasePlugIn

Public Const_ProductID As String = "40022"

Public Const ProductName As String = "Autosoft: Item Inquiry"

Public Const MinDevExpressver As String = "22.2.7"

Public Const SetMinAutoCountVer As String =

Public Const FreelyFeedbackEmail As String = "ronas02@autosoftsolution.com.my"

Public Const FreelyLicenseInformation As String = "License By Autosoft Solution Sdn Bhd"
);

AutoCount credentials can be taken from AutoCount library/database
Example: AutoCount license method in AutoCount library.
(
namespace AutoCount.PlugIn;

public class LicenseStatusArgs: BaseArgs

{

public LicenseStatus Licensestatus { get; set; } = LicenseStatus.Unregistered;

public DateTime? ExpiryDate { get; set; } = null;

public string CustomLicenseStatus { get; set; } = "Custom";

public LicenseInfo LicenseInfo { get; }

public LicenseStatusArgs(UserSession usersession, Guid guid, string plugInFolder, CompanyProfile companyProfile)

: base(userSession, guid, plugInFolder, companyProfile)

{

RemoteLicense remoteLicense = ModuleControl.GetOrCreate(userSession.DBSetting).RemoteLicense;

LicenseInfo = remoteLicense. LicenseInfo;

}

}
);

This method is in the plugin project. It is a predefined method from AutoCount that we need to implement in order to license the plugin 
(O references

Public Overrides Sub GetLicenseStatus(e As AutoCount.PlugIn.LicenseStatusArgs)

e.LicenseStatus = AutoCount.PlugIn.LicenseStatus.Custom

e.CustomLicenseStatus = FreelyPlugins. FreelyLicenseInformation

End Sub
);

There would be a controller/helper class inside the plugin project to call and show the UI 
(
Imports RootFreelyLicense

Imports RootFreelyLicense. FreelyKeyValidation

2 references

Public Class LicenseController

O references

Public Property LicenseControl As FreelyKeyValidation

1 reference

Private Property LicenseModule As List(Of LicenseModule)

1 reference

Public Sub New()

_LicenseControl = RootFreelyLicense. License.Create(FreelyPlugIns._ProductID, FreelyPlugIns.ProductName)

_LicenseControl.IdentifyLicense()

_LicenseModule = New List (Of LicenseModule) ()

End Sub

1 reference

Public Function ShowLicenseEntry() As DialogResult

Return Me._LicenseControl.ShowLicense(ShowLicenseMode.Normal)

End Function

O references

Public Function IsValidLicense() As Boolean

_LicenseControl.IdentifyLicense()

'If Debugger. IsAttached Then Return True '<--- this code is what allows debug to not have license to use

If (_LicenseControl.License.IsValid) Then

If (_LicenseControl.License.ExpiredDate.Subtract(System.DateTime.Today). Days < 0) Then

Me._LicenseControl.ShowLicense (ShowLicenseMode.Normal)

Return False

End If

Return True

Else

Me._LicenseControl.ShowLicense (ShowLicenseMode.Normal)

Return False

End If

Return False

End Function

End Class
);