Autosoft Licensing — UI Guide (wireframes → responsibilities, flow, functions, purpose & out-of-scope)

Note: Example backend method names were present previously. The text below now uses the actual service and method names implemented in this repository:
- IUserService.ValidateCredentials(username, password)
- Database user CRUD: ILicenseDatabaseService.GetUsers() / ILicenseDatabaseService.InsertUser(...) / ILicenseDatabaseService.DeleteUser(...) / ILicenseDatabaseService.UpdateUser(...)
- ILicenseRequestService.SerializeToArl(request) / ILicenseRequestService.SaveArl(path, request)
- ILicenseService.GenerateAsl(licenseData, key, iv) / ILicenseService.ImportAslBase64(base64Asl, key, iv) / ILicenseService.Activate(data, rawAslBase64, importedByUserId)
- IFileService.ReadFileBase64(path) / IFileService.WriteFileBase64(path, base64content) / IFileService.ReadBytes(path)
- ILicenseDatabaseService.GetLicenses(filter) / ILicenseDatabaseService.InsertLicense(...) / ILicenseDatabaseService.GetLicenseById(...)
- ILicenseValidationFacade.IsLicenseValid(productId, companyName, out message, out hidePluginTab)

Global app-level notes (apply to all pages)

Main container: DevExpress XtraForm (MainForm) with left navigation (Accordion/NavBar) and a PanelControl / NavigationFrame that dynamically loads page UserControls.

Role-based UI: Admin vs Support. Only Admin can access: Manage Product, Manage User, and license generation/export functionality.

Dates: All backend operations use UTC. UI displays local formatted dates, but conversions to/from UTC must be consistent.

Transient UI messages only: The UI must show transient messages and not attempt to create persistent audit logs (business requirement).

Use backend services you implemented: Example service calls used by UI (replace with actual method names in your code):

IUserService.ValidateCredentials(username, password)

ILicenseDatabaseService.GetUsers() / ILicenseDatabaseService.InsertUser(...) / ILicenseDatabaseService.DeleteUser(...)

IFileService.ReadFileBase64(path) / IFileService.ReadBytes(path) (for reading uploaded files)

ILicenseRequestService.SerializeToArl(request) / ILicenseRequestService.SaveArl(path, request)

IEncryptionService.BuildJsonWithChecksum(...) and IEncryptionService.EncryptJsonToAsl(...) (used internally by ILicenseService.GenerateAsl)

ILicenseService.GenerateAsl(licenseData, key, iv) and ILicenseService.ImportAslBase64(base64Asl, key, iv)

ILicenseService.Activate(licenseData, rawAslBase64, importedByUserId) (persist activated license metadata)

ILicenseDatabaseService.GetLicenses(filter) / ILicenseDatabaseService.InsertLicense(...) / ILicenseDatabaseService.GetLicenseById(...)

ILicenseValidationFacade.IsLicenseValid(productId, companyName, out message, out hidePluginTab)

Exact error strings (use verbatim):

Invalid license request file.

Invalid license file.

Invalid or tampered license file.

License expired.

Demo license expired.

License imported successfully.

Page map — responsibilities, flows, and UI details

Each page specification includes: Who uses it, Purpose, Main UI elements, User flow / events (what to call on actions), Validations, In-scope vs Out-of-scope, and Acceptance criteria.

1. Login Page (Dealer EXE)

Who: Dealer staff (Admin, Support).

Purpose: Authenticate users for access to dealer app features.

UI elements: Username textbox, Password textbox, Login button, inline error label.

Flow / Events:

Login clicked → call IUserService.ValidateCredentials(username, password).

On success → load MainForm (navigation + pages).

On failure → show inline error: Invalid username or password. (this message is local; not in core business strings).

Validation: Disable login if fields empty; show inline validations.

Scope: Auth store is Dealer EXE DB (in-scope). Not integrated with AutoCount SSO.

Acceptance: Correct navigation on valid credentials; error shown otherwise.

2. Generate License (Main Generate Page) — Dealer EXE

Who: Dealer Admin / License officer.

Purpose: Core license generation screen — load .ARL, configure license fields, generate license payload and key, export .ASL.

UI elements:

Upload Request File (.ARL) button (file dialog)

Auto-filled read-only fields (from .ARL): CompanyName, ProductID, DealerCode, Currency

Editable: IssueDate (default today), ExpireDate (auto-calc based on LicenseType and requested months), Remarks

License Type radio: Demo / Subscription / Permanent (Demo auto-forces 1 month)

Modules checklist (multi-select)

Generate License Key button → displays license key in textbox

Download License (.ASL) button → saves encrypted license file

Preview panel → formatted (pre-encryption) license JSON

Validation messages area

Flow / Events:

Upload .ARL → read file using IFileService.ReadFileBase64(path) or IFileService.ReadBytes(path), deserialize to `LicenseRequest` and validate using IValidationService.ValidateLicenseRequest(...); if invalid → show "Invalid license request file." and halt.

Admin may adjust modules/expiry (obey business rules).

Click Generate License Key → build a `LicenseData` instance from inputs then call ILicenseService.GenerateAsl(licenseData, key, iv) to produce the encrypted Base64 .ASL (internally the service will compute checksum and encrypt). Show license key (LicenseData.LicenseKey).

Click Download License → call ILicenseService.GenerateAsl(...) to get Base64 ASL, then IFileService.WriteFileBase64(path, base64Asl) to save the file. Show success message: License generated successfully. (Dealer EXE).

Optionally insert record to DB: ILicenseDatabaseService.InsertLicense(...). Use ILicenseDatabaseService.SetLicenseModules(...) to persist modules if needed.

Validation & Messages:

If .ARL required fields missing → Invalid license request file.

If encryption errors → generic error: Failed to generate license. Contact admin.

Ensure Demo selection disables editing of requested months > 1.

Scope: Dealer EXE generates .ASL (in-scope). Payment and approvals are manual (out-of-scope). No remote servers.

Acceptance: .ARL correctly parsed, license key generated, .ASL saved and decryptable by Client DLL.

3. License Records — Dealer EXE

Who: Dealer Admin / Support.

Purpose: Search/list previously generated licenses and .ARL requests; inspect status and expiration countdown.

UI elements:

Filters: CompanyName (dropdown), ProductCode, LicenseType, IssueDate / ExpiryDate (date or range), Show expired license checkbox, Countdown(days) selector

Refresh button

Grid: columns (CompanyName, ProductCode, ProductName, LicenseType, IssueDate, ExpiryDate, Status, Countdown)

Row color coding: Active (normal), Soon-to-expire (yellow), Expired (red)

Buttons: Create, View, Edit, Delete

Flow / Events:

Refresh → call ILicenseDatabaseService.GetLicenses(filter) and bind grid.

View → open License Details page.

Edit → prefill Generate page for manual adjustments (Admin only).

Delete → confirm then ILicenseDatabaseService.DeleteLicense(...) (if implemented) or implement appropriate delete flow in ILicenseDatabaseService (Admin only). In current code the database API exposes InsertLicense, GetLicenseById, GetLicenses and SetLicenseModules — use these as available.

Validation: Date range validation; filter inputs sanitized.

Scope: No audit logs per requirement. Delete only affects dealer DB / local record.

Acceptance: Filters work; grid shows statuses with color coding.

4. License Details / Manual Edit — Dealer EXE

Who: Dealer Admin.

Purpose: View and optionally edit license metadata (expiry, modules). Admins can manually adjust subscription durations.

UI elements: Display license fields, modules list, Edit toggle, Save / Back.

Flow / Events:

Load via ILicenseDatabaseService.GetLicenseById(id).

Save → persist changes. The solution exposes ILicenseDatabaseService.SetLicenseModules(...) for modules and ILicenseDatabaseService.InsertLicense(...) for adding licenses. There is no generic UpdateLicense(...) method in the current ILicenseDatabaseService interface — implementers should use available methods (InsertLicense / SetLicenseModules / UpdateLicenseStatus) or add a DB API if in-place updates are required.

If Admin wants to re-issue an .ASL, they must regenerate via Generate page (call ILicenseService.GenerateAsl(...) and write file with IFileService.WriteFileBase64(...)).

Validation: Expiry >= IssueDate; prompt confirmation for critical changes.

Scope: Changing DB record does not automatically update customer .ASL — re-issue is manual.
	
Acceptance: Save persists changes to DB (via the available DB APIs).

5. Manage Product (Products & Modules) — Dealer EXE

Who: Product Manager / Dealer Admin.

Purpose: CRUD product definitions and module lists used by license payloads.

UI elements: Product list grid, Create / View / Edit / Delete, product form with modules table and release notes.

Flow / Events:

Use ILicenseDatabaseService.GetProducts() / InsertProduct(...) / UpdateProduct(...) / DeleteProduct(...) to manage products and modules.

Product metadata populates Generate page module checklist.

Scope: Products are dealer-managed; plugin developers reference ProductID in their plugin code (out-of-scope for this app).

Acceptance: Product changes reflect in Generate page.

6. Manage User / Access Rights — Dealer EXE

Who: Dealer Admin.

Purpose: Manage dealer application users and their permissions (Generate License, View Records, Manage Product, Manage User).

UI elements: Users grid, Create / Edit / Delete buttons, user form with access checkboxes. Prevent deletion of default Admin.

Flow / Events:

CRUD via ILicenseDatabaseService.GetUsers() / InsertUser(...) / UpdateUser(...) / DeleteUser(...).

Enforce rules: cannot delete the default Admin; at least one Admin must remain.

Scope: Dealer EXE local auth only; no AutoCount integration.

Acceptance: Access controls enforced in UI.

7. (Separate component) Client License Entry / Register Page — LicenseClient.dll (embedded into plugin)

Important: This is not part of the Dealer EXE. It’s a separate Client DLL consumed by plugin projects. Included here for clarity only.

Who: End user (customer) inside AutoCount.

Purpose: Create .ARL requests and import .ASL license files inside the plugin.

UI elements: Tabs: License Entry / License Information; fields: ProductKey, ProductName, CompanyName, Currency, ProgramVersion, LicenseKey, IssueDate, ExpireDate, status area; Save Request File, Register By File, Verify.

Flow / Events:

Save Request File → call ILicenseRequestService.SerializeToArl(request) to build canonical JSON and then ILicenseRequestService.SaveArl(path, request) to write .ARL.

Register By File → file dialog → read file using IFileService.ReadFileBase64(path) and call ILicenseService.ImportAslBase64(base64Asl, key, iv). If Import succeeds (no ValidationException) then persist license metadata locally — the repository does not provide a dedicated ILicenseStorageService for client-local persistence; client DLLs should implement their own storage (for example using IFileService.WriteFileBase64 or an application-specific encrypted file) and then show the exact success string: License imported successfully. On failure show the exact error string returned from the service (e.g., "Invalid or tampered license file.", "License expired.", "Demo license expired.", or "Invalid license file.").

Verify → use ILicenseValidationFacade.IsLicenseValid(productId, companyName, out message, out hidePluginTab) to check current validity and get the UI message / whether to hide the plugin tab.

Validation: On .ASL checksum failure → Invalid or tampered license file. On expiry → License expired. or Demo license expired.

Scope: Values CompanyName, ProductID, ProductName are supplied by plugin host via LicenseControl.Initialize(...). DLL must not query AutoCount internals itself.

Acceptance: .ARL saved; .ASL import validates and persists.

8. Client License Info / Read-only Display — LicenseClient.dll

Purpose: Display current persisted license and allow removal/re-registration.

UI elements: Read-only labels for license fields, Remove License, Re-register, Export optional. Banner for demo expiry with Demo license expired. message.

Flow / Events: Read from client storage on load (client DLL must implement storage — IFileService may be used for basic file operations). Remove calls the client storage clear implementation.

Scope: Plugin must call DLL to act on license state (hide features if invalid).

Acceptance: Accurate display and removal behavior.

Data that is explicitly OUT OF SCOPE (the UI must NOT fetch these directly)

These must be passed into the UI or provided by the plugin host or other modules:

CompanyName — provided by plugin host (for client DLL) or included in .ARL (for Dealer EXE). Do not query AutoCount DB directly.

ProductID, ProductName, ProgramVersion — hardcoded by plugin developers; plugin passes them to client DLL.

AutoCount login events — plugin developers will call IsValidLicense() during their login flow (use ILicenseValidationFacade.IsLicenseValid(...)).

Machine/session tokens — for fingerprinting, plugin host supplies a fingerprint or callback IMachineFingerprintProvider.

Payment & renewal approvals — manual; not automated by this app.

Central/remote license server — none; do not call remote APIs.

AutoCount DB schema internals — plugin devs are responsible for integration.

UI acceptance & integration tests (suggested)

Upload valid .ARL → Generate page populates → Generate key → .ASL saved and round-trips to Client DLL without checksum failure.

Import a tampered .ASL → UI shows Invalid or tampered license file.

Import expired .ASL → UI shows License expired. or Demo license expired. as appropriate.

Manage Product: add module → visible in Generate page modules checklist.

Manage User: cannot delete default Admin account; permissions respected in UI.

File / UserControl naming & suggested mapping (for Copilot)
`/UI/MainForm.cs`
`/UI/Pages/GenerateLicensePage.cs`
`/UI/Pages/LicenseRecordsPage.cs`
`/UI/Pages/LicenseDetailsPage.cs`
`/UI/Pages/ManageProductPage.cs`
`/UI/Pages/ManageUserPage.cs`
`/UI/Pages/LoginPage.cs`
`/UI/Shared/Notifications.cs`
// For client DLL (separate project)
 `/Client/UI/ClientLicenseEntryControl.cs`
 `/Client/UI/ClientLicenseInfoControl.cs`